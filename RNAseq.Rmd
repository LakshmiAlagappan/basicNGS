---
title: "RNAseq"
author: "Lakshmi"
date: "2024-07-05"
output: html_document
---

# Basic tutorial on RNASeq

## Installing and Loading the packages
```{r, message = FALSE}
# All packages need to be downloaded

# install.packages(tidyverse)
# install.packages(ggplot)
# install.packages(ggrepel)

# if (!require("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# BiocManager::install("DESeq2")
# BiocManager::install("ComplexHeatmap")
# BiocManager::install("clusterProfiler")
# BiocManager::install("org.Hs.eg.db")
# BiocManager::install("apeglm")

## Loading all the necessary packages
library(tidyverse) #data
library(ggplot2) #plot
library(ggrepel) #plot

library(DESeq2) #ngs
library(ComplexHeatmap) #plot
library(clusterProfiler) #pathway
library(org.Hs.eg.db) #pathway
library(apeglm)

source("./visualizer.R")
```

## load data 
Its a count matrix and meta data. The process of how rna reads became count matrix is a black box for now. Will work on it after this. 
```{r}
counts <- read.csv("./data/tutorial_counts.csv", check.names = FALSE)
metadata <- read.csv("./data/tutorial_metadata.csv", row.names = 1)
```

This basically sets the basis of the analysis, with "Mock" being level 1 and "Virus being level 2
```{r}
str(metadata)
metadata$Strain = factor(metadata$Strain)
metadata$Strain = relevel(metadata$Strain, ref = "Mock")
```

This analysis below shows that the count matrix has duplicated "gene names" but in actual it is all "-" genes without names
```{r}
head(counts)
dim(counts)
length(unique(counts$GeneSymbol))
counts[duplicated(counts$GeneSymbol),]
```

Here, we have piped counts to do a grouping by gene symbol, then summarizing "across" every column ("everything") using mean. Now, its no more duplicated. However, note that this made the "counts" float. Need to convert this to integer. 
```{r}
avg_counts = counts %>% group_by(GeneSymbol) %>% summarise(across(everything(),mean))%>%column_to_rownames("GeneSymbol")
avg_counts = avg_counts %>% mutate(across(everything(),as.integer))#cant do as.integer(avg_counts) as its a tibble not a base data.frame. This also lets go of the gene symbol column (str), and now we have only 6 columns. 
```

## DESeq2

Now, we are ready for DESeq Analysis. First we get the DESeq dataset 
```{r}
dds = DESeqDataSetFromMatrix(avg_counts, colData = metadata, design = ~ Strain) #relationship between all the variables (~) with Strain 
saveRDS(dds, "./results/dds.rds")
```

Now, we do soft filtering
```{r}
#default is normalized = FALSE. For every gene, we check whether the counts in the strain is >= 10 for alteast >= 3 samples
dim(dds)
idx <- rowSums(counts(dds, normalized=FALSE) >= 10) >= 3
dds_filtered <- dds[idx, ]
dim(dds_filtered) # So many of them have so few counts that we have ignored them
```

```{r}
dds_deseq = DESeq(dds_filtered)
saveRDS(dds_deseq, "./results/dds_deseq.rds")
head(results(dds_deseq))
#MLE: Maximum liklihood estimation
#baseMEan is the average normalizes count values with the size factor 
#log2 fold change indicates the expression level of the test wrt to the control
#lfcse log fold change standard error 
#stat, pvalue and adjusted for many samples
```

## factors in DESEQ
```{r}
#Size factors
sizeFactors(dds_deseq) #We likely divide this on the counts to get normalized counts
colSums(counts(dds_filtered)) #total counts for every sample. this is sort of proportional to the size factors

#Dispersion
# Dispersion is a measure of spread or variability in the data. Dispersion of 0.01 means that there is 10% variation around the mean expected across biological replicates
# lower mean, higher dispersion; higher mean lower dispersion; same mean, depends on variance
# Dispersion is an estimation (different from variance) based on shrinkage. Increasing mean counts decreasing dispersion. Any different plot will be bad and not suitable for DESEQ

plotDispEsts(dds_deseq)
```

Independent filtering to get rid of unnecessary genes. Then we do log fold change shrinkage.
Genes with large fold changes not due to low read counts remain un-shrunken while large fold changes and low read counts are shrunken.

```{r}
dds_deseq_sig_res = results(dds_deseq, independentFiltering = TRUE, alpha = 0.05)
summary(dds_deseq_sig_res)
dds_deseq_sig_res_lfc <- lfcShrink(dds_deseq, coef = 2, res = dds_deseq_sig_res) #This doesn't change the baseMean, pvalue or the adjusted p value. Only the log fold change is reduced and the associated lfcse is changed. 
dds_deseq_sig_res_lfc
```

Now, we make the de dataframe for visualization
```{r}
res_de = data.frame(dds_deseq_sig_res_lfc)
res_de = res_de %>% drop_na(padj)
head(res_de)
```


```{r}
countNorm = counts(dds_deseq, normalized = TRUE) %>% as.data.frame()
head(countNorm)
```

```{r}
calc_numDEGvsFC = function(df_df, logFC_name = 'log2FoldChange',logFC_threshold = 2, 
                           padj_name = 'padj', padj_threshold = 0.05, step = 0.2){
  
  fc_range = seq(0, logFC_threshold, step)
  nDE_vct = c()
  for (logFC in fc_range){
    nDE = data.frame(df_df) %>% filter(get(padj_name) < padj_threshold, 
                                get(logFC_name) > logFC | get(logFC_name) < -logFC)
    nDE_vct = append(nDE_vct, length(rownames(nDE)))
  }
  cumulative_DE_df = data.frame(fc_range,nDE_vct)
  colnames(cumulative_DE_df) = c("logFC", "nDEG")
  return(cumulative_DE_df)
}

calc_volcano <- function(df_df,logFC_name = 'log2FoldChange', logFC_threshold = 2,
                         padj_name = 'padj', padj_threshold = 0.05){
  
  df_df_res <- data.frame(df_df) %>%
    mutate(diffExpressed = case_when(get(padj_name) < padj_threshold & 
                                       get(logFC_name) > logFC_threshold ~ "UP",
                                     get(padj_name) < padj_threshold & 
                                       get(logFC_name) < -logFC_threshold ~ "DOWN",
                                     .default = "NO"), neglog10padj = -log10(get(padj_name)))
  #We have mutated the df to add two columns, diffExpressed and neg_log10_padj
  df_df_res$diffExpressed = factor(df_df_res$diffExpressed, levels = c("UP", "DOWN", "NO"))
  return(df_df_res)
}

cumulative_DE_dfans = calc_numDEGvsFC(res_de)
plot_line(cumulative_DE_dfans, c1, c("#DEG vs Log2FC", "Log 2 Fold Change", "# Differentially expressed genes"), marker = TRUE)

volcano_res = calc_volcano(res_de)
plot_volcano(volcano_res, col_vol, c("Volano Plot", "Log2 Fold Change", "- Log10 p-adj", "Genes"))
```

Now, lets go ahead and do pathway analysis

```{r}
enrich_ez <- function(genelist, universe, select_dataset, organism="org.Hs.eg.db") {
  #If the database has the word "GO", snip the remaining into ont
  if (stringr::str_detect(select_dataset, "GO")) {
    ont <- stringr::str_sub(select_dataset, start = 3L) #ont is ontology
    select_enrich = clusterProfiler::enrichGO(gene = genelist, universe = universe,
                      OrgDb = organism, keyType = "SYMBOL",
                      readable = T, ont = ont,
                      pvalueCutoff = 0.1, qvalueCutoff = 0.10)
  } else {
    db <- clusterProfiler::read.gmt(select_dataset)
    select_enrich = clusterProfiler::enricher(genelist, TERM2GENE = db, universe = universe,
                              pvalueCutoff = 0.1, qvalueCutoff = 0.10)
  }
  return(select_enrich)
}

res_de_up = res_de%>%filter(padj < 0.05 & log2FoldChange >2 )
gobp_up <- enrich_ez(genelist = rownames(res_de_up),
                     universe = rownames(res_de),
                     select_dataset = "GOBP",
                     organism = "org.Hs.eg.db")
head(gobp_up)
plot_enrich_std(gobp_up@result, col_enrich, c("","Description", "-Log10 adj-p","Bar"),
                pos_neg = "pos")

res_de_down = res_de%>%filter(padj < 0.05 & log2FoldChange < -2 )
gobp_down <- enrich_ez(genelist = rownames(res_de_down),
                     universe = rownames(res_de),
                     select_dataset = "GOBP",
                     organism = "org.Hs.eg.db")
head(gobp_down)
plot_enrich_std(gobp_up@result, col_enrich, c("","Description", "-Log10 adj-p","Bar"),
                pos_neg = "neg")

cnetplot(gobp_down,showCategory = 5, 
         color.params = list(foldChange = res_de_down$log2FoldChange),
         cex.params = list(category_label = 0.8, gene_label = 0.6))

```

# GSEA: Gene Set Enrichment Analysis

```{r}
#We need the gene names and its log fold change for the GSEA analysis
logfc_list <- res_de$log2FoldChange
names(logfc_list) <- rownames(res_de)
logfc_list <- sort(logfc_list, decreasing = TRUE) # GSEA requires a rank in decreasing order

set.seed(123) # keeps results consistent as gsea relies on random sampling
gobp_gsea <- gseGO(geneList=logfc_list, ont ="BP",
                                 keyType = "SYMBOL", minGSSize = 3, 
                                 maxGSSize = 800, pvalueCutoff = 0.05, 
                                 verbose = TRUE, OrgDb = org.Hs.eg.db,
                                 pAdjustMethod = "fdr")


plot_enrich_std(gobp_gsea@result, col_enrich, c("","Description", "-Log10 adj-p","Bar"),
                pos_neg = "neg")

BTM <- read.gmt("./data/BTM.gmt")

btm_gsea <- GSEA(geneList = logfc_list, TERM2GENE=BTM,
                 minGSSize = 3, maxGSSize = 800, pvalueCutoff = 0.05,
                 verbose = TRUE, pAdjustMethod = "fdr")


```




